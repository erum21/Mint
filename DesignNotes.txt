TODO next:
  'expectedType' in evaluator.
  -- add EnumType, and let options support enums.
  -- Get rid of GraphBuilder.
  -- Think about scanners
    -- when do they run?
    -- how to parse the output
    
What we need is some sort of syntax that says:
  proto | object { attr = value; attr = value }
  
Which essentially means to copy all parameters from 'object' into the new object, as long
as there is a parameter in 'proto' that matches the name and type.

  actions => let s = self : clang {{ self }} .compile
  actions => let s = self : clang { ** self; arg = value; arg = value; }.compile
  actions => let s = self : clang { s; arg = value; arg = value; }.compile
  actions => clang { import self; arg = value; arg = value }.compile
  actions => clang | self { arg = value; arg = value }.compile

  implicit_depends => sources.map(
      src => builder_map[path.ext(src)] :: self {
           sources = [ src ]
      })
  
  implicit_depends => sources.map(
      src => builder_map[path.ext(src)] {
           sources = [ src ]
      } (self))
  
Design issues:
  -- how to pass common compiler options around to tests and targets.
  -- and yet keep the options as platform-independent as possible.

TODO later:
  -- compiler choice (clang)
  -- serialize configuration graph.
  -- load configuration graph.
  -- Trim leading space from multi-line string literals.
  
* Algorithm for parallel target builds.
  - targets are in the following states:
    - unchecked
    - up-to-date
    - out-of-date
    - building
    - error

What do targets need?
  -- deps
  -- state

What do file targets need?
  -- relative path
  -- base directory
  -- parameters used to build the target the previous time. (or hash thereof.)
  -- date
  -- size
  
Target queues:
  -- done
  -- waiting on deps
  -- ready to build

We also need platform-specific file suffixes. (.o vs. .obj)

# Here's how we might define gcc. There's a standard namespace called 'compilers',
# of which 'gcc' is a member.
# (Note: This isn't mutating the 'compilers' namespace. We might instead have
# written this as 'compilers = super.compilers { gcc = compiler { ... }}.)
compilers.gcc = compiler {
  # Convert the compiler parameters into the appropriate gcc flags.
  # Because flags is a param, the user can override it in a subclass to add custom
  # flags.
  param flags = [
    cond(debug "-g")
    cond(optLevel > 0 "-O${optLevel}")
    map(sym => "-D${sym}", defines)
  ]
  name = "gcc"
  arguments = [
    flags
    map(dir => ["-I" dir], includePath])  # Convert include paths to -I params.
    "-o" out
    source]
  # The action is to run the program as a shell command.
  # The argument list may contain nested lists - these all get flattened and
  # converted to an argv array. The third argument is the working directory.
  action = shell(programName, arguments, out.path.dir)
}

# Select either msvc or gcc based on the current host
compilers:cplusplus = cond(host == "WIN32" compilers:msvc compilers:gcc)

# Now define a rule for targets that use gcc
executable.cpp = target.file {
  param options = {}
  tool = compilers.gcc {
    sources = sources
    # Make sure that the output file has the right file extension.
    output = setExtension(output, host.extension.executable)
    aux-output = aux-output
    # Pass all of the options to the tool
    *options
  }
}

/////

#cpp = tool {
#  param sources : list[string] = []
#  param include_dirs : list[string] = []
#  param library_dirs : list[string] = []
#  param flags : list[string] = []
#  lazy param include_flags : list[string] = map(include_dirs, dir => ["-I", dir])
#  lazy param compile : list[function] = [
#    shell("g++", flags ++ include_flags)
#  ]
#  lazy param gendeps : list[function] = [
#    shell("g++", flags ++ include_flags)
#  ]
#  lazy param test : list[function] = [
#    shell("g++", flags ++ include_flags)
#  ]
#}

class Value {
  Type * type;
  union {
    Node * n;
    bool b;
    int i;
    double d;
  }
}
