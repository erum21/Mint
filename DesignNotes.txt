TODO today:
  'expectedType'
  
* Algorithm for parallel target builds.
  - targets are in the following states:
    - unchecked
    - up-to-date
    - out-of-date
    - building
    - error

What do targets need?
  -- deps
  -- state

What do file targets need?
  -- relative path
  -- base directory
  -- parameters used to build the target the previous time. (or hash thereof.)
  -- date
  -- size
  
Target queues:
  -- done
  -- waiting on deps
  -- ready to build

We also need platform-specific file suffixes. (.o vs. .obj)

# Here's how we might define gcc. There's a standard namespace called 'compilers',
# of which 'gcc' is a member.
# (Note: This isn't mutating the 'compilers' namespace. We might instead have
# written this as 'compilers = super.compilers { gcc = compiler { ... }}.)
compilers.gcc = compiler {
  # Convert the compiler parameters into the appropriate gcc flags.
  # Because flags is a param, the user can override it in a subclass to add custom
  # flags.
  param flags = [
    cond(debug "-g")
    cond(optLevel > 0 "-O${optLevel}")
    map(sym => "-D${sym}", defines)
  ]
  name = "gcc"
  arguments = [
    flags
    map(dir => ["-I" dir], includePath])  # Convert include paths to -I params.
    "-o" out
    source]
  # The action is to run the program as a shell command.
  # The argument list may contain nested lists - these all get flattened and
  # converted to an argv array. The third argument is the working directory.
  action = shell(programName, arguments, out.path.dir)
}

# Select either msvc or gcc based on the current host
compilers:cplusplus = cond(host == "WIN32" compilers:msvc compilers:gcc)

# Now define a rule for targets that use gcc
executable.cpp = target.file {
  param options = {}
  tool = compilers.gcc {
    sources = sources
    # Make sure that the output file has the right file extension.
    output = setExtension(output, host.extension.executable)
    aux-output = aux-output
    # Pass all of the options to the tool
    *options
  }
}

/////

#cpp = tool {
#  param sources : list[string] = []
#  param include_dirs : list[string] = []
#  param library_dirs : list[string] = []
#  param flags : list[string] = []
#  lazy param include_flags : list[string] = map(include_dirs, dir => ["-I", dir])
#  lazy param compile : list[function] = [
#    shell("g++", flags ++ include_flags)
#  ]
#  lazy param gendeps : list[function] = [
#    shell("g++", flags ++ include_flags)
#  ]
#  lazy param test : list[function] = [
#    shell("g++", flags ++ include_flags)
#  ]
#}
