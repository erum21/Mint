TODO next:
  'expectedType' in evaluator.
  -- add EnumType, and let options support enums.
  -- Get rid of GraphBuilder.
  -- Think about scanners
    -- when do they run?
    -- how to parse the output

TODO later:
  -- compiler choice (clang)
  -- serialize configuration graph.
  -- load configuration graph.
  -- Trim leading space from multi-line string literals.
  -- String escaping.
  
We also need platform-specific file suffixes. (.o vs. .obj)

# Here's how we might define gcc. There's a standard namespace called 'compilers',
# of which 'gcc' is a member.
# (Note: This isn't mutating the 'compilers' namespace. We might instead have
# written this as 'compilers = super.compilers { gcc = compiler { ... }}.)
compilers.gcc = compiler {
  # Convert the compiler parameters into the appropriate gcc flags.
  # Because flags is a param, the user can override it in a subclass to add custom
  # flags.
  param flags = [
    cond(debug "-g")
    cond(optLevel > 0 "-O${optLevel}")
    map(sym => "-D${sym}", defines)
  ]
  name = "gcc"
  arguments = [
    flags
    map(dir => ["-I" dir], includePath])  # Convert include paths to -I params.
    "-o" out
    source]
  # The action is to run the program as a shell command.
  # The argument list may contain nested lists - these all get flattened and
  # converted to an argv array. The third argument is the working directory.
  action = shell(programName, arguments, out.path.dir)
}

# Select either msvc or gcc based on the current host
compilers:cplusplus = cond(host == "WIN32" compilers:msvc compilers:gcc)

# Now define a rule for targets that use gcc
executable.cpp = target.file {
  param options = {}
  tool = compilers.gcc {
    sources = sources
    # Make sure that the output file has the right file extension.
    output = setExtension(output, host.extension.executable)
    aux-output = aux-output
    # Pass all of the options to the tool
    *options
  }
}

/////

class Value {
  Type * type;
  union {
    Node * n;
    bool b;
    int i;
    double d;
  }
}
